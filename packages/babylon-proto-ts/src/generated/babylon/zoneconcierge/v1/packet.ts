// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: babylon/zoneconcierge/v1/packet.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { SubmissionKey } from "../../btccheckpoint/v1/btccheckpoint";
import { BTCHeaderInfo } from "../../btclightclient/v1/btclightclient";
import { BTCStakingIBCPacket } from "../../btcstaking/v1/packet";
import { RawCheckpoint } from "../../checkpointing/v1/checkpoint";
import { Epoch } from "../../epoching/v1/epoching";
import { Evidence } from "../../finality/v1/finality";
import { IndexedHeader, ProofFinalizedChainInfo } from "./zoneconcierge";

export const protobufPackage = "babylon.zoneconcierge.v1";

/** OutboundPacket represents packets sent from Babylon to other chains */
export interface OutboundPacket {
  btcTimestamp?: BTCTimestamp | undefined;
  btcStaking?: BTCStakingIBCPacket | undefined;
  btcHeaders?: BTCHeaders | undefined;
}

/** InboundPacket represents packets received by Babylon from other chains */
export interface InboundPacket {
  consumerSlashing?: ConsumerSlashingIBCPacket | undefined;
  bsnBaseBtcHeader?: BSNBaseBTCHeaderIBCPacket | undefined;
}

/**
 * BTCHeaders contains BTC headers that have been verified and inserted into Babylon's BTC light client
 * These headers are forwarded to consumer chains to keep their light clients in sync with Babylon
 */
export interface BTCHeaders {
  headers: BTCHeaderInfo[];
}

/**
 * BTCTimestamp is a BTC timestamp that carries information of a BTC-finalised epoch.
 * It includes a number of BTC headers, a raw checkpoint, an epoch metadata, and
 * a Cosmos Consumer header if there exists Cosmos Consumer headers checkpointed to this epoch.
 * Upon a newly finalised epoch in Babylon, Babylon will send a BTC timestamp to each
 * consumer chain via IBC.
 */
export interface BTCTimestamp {
  /** header is the last Cosmos Consumer header in the finalized Babylon epoch */
  header:
    | IndexedHeader
    | undefined;
  /**
   * btc_headers is BTC headers between
   * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
   * - BTC tip at epoch `lastFinalizedEpoch`
   * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
   */
  btcHeaders:
    | BTCHeaders
    | undefined;
  /** epoch_info is the metadata of the sealed epoch */
  epochInfo:
    | Epoch
    | undefined;
  /** raw_checkpoint is the raw checkpoint that seals this epoch */
  rawCheckpoint:
    | RawCheckpoint
    | undefined;
  /** btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch */
  btcSubmissionKey:
    | SubmissionKey
    | undefined;
  /** Proofs that the header is finalized */
  proof: ProofFinalizedChainInfo | undefined;
}

/**
 * ConsumerSlashingIBCPacket defines the slashing information that a Consumer sends to Babylon's ZoneConcierge upon a
 * Consumer slashing event.
 * It includes the FP public key, the Consumer block height at the slashing event, and the double sign evidence.
 */
export interface ConsumerSlashingIBCPacket {
  /** / evidence is the FP slashing evidence that the Consumer sends to Babylon */
  evidence: Evidence | undefined;
}

/**
 * BSNBaseBTCHeaderIBCPacket defines the base BTC header information that a BSN sends to Babylon's ZoneConcierge
 * to inform Babylon about which BTC header the BSN considers as its starting point for BTC light client synchronization
 */
export interface BSNBaseBTCHeaderIBCPacket {
  /** base_btc_header is the BTC header that the BSN uses as the base for its BTC light client */
  baseBtcHeader: BTCHeaderInfo | undefined;
}

function createBaseOutboundPacket(): OutboundPacket {
  return { btcTimestamp: undefined, btcStaking: undefined, btcHeaders: undefined };
}

export const OutboundPacket: MessageFns<OutboundPacket> = {
  encode(message: OutboundPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.btcTimestamp !== undefined) {
      BTCTimestamp.encode(message.btcTimestamp, writer.uint32(10).fork()).join();
    }
    if (message.btcStaking !== undefined) {
      BTCStakingIBCPacket.encode(message.btcStaking, writer.uint32(18).fork()).join();
    }
    if (message.btcHeaders !== undefined) {
      BTCHeaders.encode(message.btcHeaders, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.btcTimestamp = BTCTimestamp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.btcStaking = BTCStakingIBCPacket.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.btcHeaders = BTCHeaders.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutboundPacket {
    return {
      btcTimestamp: isSet(object.btcTimestamp) ? BTCTimestamp.fromJSON(object.btcTimestamp) : undefined,
      btcStaking: isSet(object.btcStaking) ? BTCStakingIBCPacket.fromJSON(object.btcStaking) : undefined,
      btcHeaders: isSet(object.btcHeaders) ? BTCHeaders.fromJSON(object.btcHeaders) : undefined,
    };
  },

  toJSON(message: OutboundPacket): unknown {
    const obj: any = {};
    if (message.btcTimestamp !== undefined) {
      obj.btcTimestamp = BTCTimestamp.toJSON(message.btcTimestamp);
    }
    if (message.btcStaking !== undefined) {
      obj.btcStaking = BTCStakingIBCPacket.toJSON(message.btcStaking);
    }
    if (message.btcHeaders !== undefined) {
      obj.btcHeaders = BTCHeaders.toJSON(message.btcHeaders);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutboundPacket>, I>>(base?: I): OutboundPacket {
    return OutboundPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutboundPacket>, I>>(object: I): OutboundPacket {
    const message = createBaseOutboundPacket();
    message.btcTimestamp = (object.btcTimestamp !== undefined && object.btcTimestamp !== null)
      ? BTCTimestamp.fromPartial(object.btcTimestamp)
      : undefined;
    message.btcStaking = (object.btcStaking !== undefined && object.btcStaking !== null)
      ? BTCStakingIBCPacket.fromPartial(object.btcStaking)
      : undefined;
    message.btcHeaders = (object.btcHeaders !== undefined && object.btcHeaders !== null)
      ? BTCHeaders.fromPartial(object.btcHeaders)
      : undefined;
    return message;
  },
};

function createBaseInboundPacket(): InboundPacket {
  return { consumerSlashing: undefined, bsnBaseBtcHeader: undefined };
}

export const InboundPacket: MessageFns<InboundPacket> = {
  encode(message: InboundPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerSlashing !== undefined) {
      ConsumerSlashingIBCPacket.encode(message.consumerSlashing, writer.uint32(10).fork()).join();
    }
    if (message.bsnBaseBtcHeader !== undefined) {
      BSNBaseBTCHeaderIBCPacket.encode(message.bsnBaseBtcHeader, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InboundPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerSlashing = ConsumerSlashingIBCPacket.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bsnBaseBtcHeader = BSNBaseBTCHeaderIBCPacket.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InboundPacket {
    return {
      consumerSlashing: isSet(object.consumerSlashing)
        ? ConsumerSlashingIBCPacket.fromJSON(object.consumerSlashing)
        : undefined,
      bsnBaseBtcHeader: isSet(object.bsnBaseBtcHeader)
        ? BSNBaseBTCHeaderIBCPacket.fromJSON(object.bsnBaseBtcHeader)
        : undefined,
    };
  },

  toJSON(message: InboundPacket): unknown {
    const obj: any = {};
    if (message.consumerSlashing !== undefined) {
      obj.consumerSlashing = ConsumerSlashingIBCPacket.toJSON(message.consumerSlashing);
    }
    if (message.bsnBaseBtcHeader !== undefined) {
      obj.bsnBaseBtcHeader = BSNBaseBTCHeaderIBCPacket.toJSON(message.bsnBaseBtcHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InboundPacket>, I>>(base?: I): InboundPacket {
    return InboundPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InboundPacket>, I>>(object: I): InboundPacket {
    const message = createBaseInboundPacket();
    message.consumerSlashing = (object.consumerSlashing !== undefined && object.consumerSlashing !== null)
      ? ConsumerSlashingIBCPacket.fromPartial(object.consumerSlashing)
      : undefined;
    message.bsnBaseBtcHeader = (object.bsnBaseBtcHeader !== undefined && object.bsnBaseBtcHeader !== null)
      ? BSNBaseBTCHeaderIBCPacket.fromPartial(object.bsnBaseBtcHeader)
      : undefined;
    return message;
  },
};

function createBaseBTCHeaders(): BTCHeaders {
  return { headers: [] };
}

export const BTCHeaders: MessageFns<BTCHeaders> = {
  encode(message: BTCHeaders, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.headers) {
      BTCHeaderInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCHeaders {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCHeaders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.headers.push(BTCHeaderInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCHeaders {
    return {
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => BTCHeaderInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BTCHeaders): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => BTCHeaderInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCHeaders>, I>>(base?: I): BTCHeaders {
    return BTCHeaders.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCHeaders>, I>>(object: I): BTCHeaders {
    const message = createBaseBTCHeaders();
    message.headers = object.headers?.map((e) => BTCHeaderInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBTCTimestamp(): BTCTimestamp {
  return {
    header: undefined,
    btcHeaders: undefined,
    epochInfo: undefined,
    rawCheckpoint: undefined,
    btcSubmissionKey: undefined,
    proof: undefined,
  };
}

export const BTCTimestamp: MessageFns<BTCTimestamp> = {
  encode(message: BTCTimestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      IndexedHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.btcHeaders !== undefined) {
      BTCHeaders.encode(message.btcHeaders, writer.uint32(18).fork()).join();
    }
    if (message.epochInfo !== undefined) {
      Epoch.encode(message.epochInfo, writer.uint32(26).fork()).join();
    }
    if (message.rawCheckpoint !== undefined) {
      RawCheckpoint.encode(message.rawCheckpoint, writer.uint32(34).fork()).join();
    }
    if (message.btcSubmissionKey !== undefined) {
      SubmissionKey.encode(message.btcSubmissionKey, writer.uint32(42).fork()).join();
    }
    if (message.proof !== undefined) {
      ProofFinalizedChainInfo.encode(message.proof, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCTimestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = IndexedHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.btcHeaders = BTCHeaders.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.epochInfo = Epoch.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rawCheckpoint = RawCheckpoint.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.btcSubmissionKey = SubmissionKey.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.proof = ProofFinalizedChainInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCTimestamp {
    return {
      header: isSet(object.header) ? IndexedHeader.fromJSON(object.header) : undefined,
      btcHeaders: isSet(object.btcHeaders) ? BTCHeaders.fromJSON(object.btcHeaders) : undefined,
      epochInfo: isSet(object.epochInfo) ? Epoch.fromJSON(object.epochInfo) : undefined,
      rawCheckpoint: isSet(object.rawCheckpoint) ? RawCheckpoint.fromJSON(object.rawCheckpoint) : undefined,
      btcSubmissionKey: isSet(object.btcSubmissionKey) ? SubmissionKey.fromJSON(object.btcSubmissionKey) : undefined,
      proof: isSet(object.proof) ? ProofFinalizedChainInfo.fromJSON(object.proof) : undefined,
    };
  },

  toJSON(message: BTCTimestamp): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = IndexedHeader.toJSON(message.header);
    }
    if (message.btcHeaders !== undefined) {
      obj.btcHeaders = BTCHeaders.toJSON(message.btcHeaders);
    }
    if (message.epochInfo !== undefined) {
      obj.epochInfo = Epoch.toJSON(message.epochInfo);
    }
    if (message.rawCheckpoint !== undefined) {
      obj.rawCheckpoint = RawCheckpoint.toJSON(message.rawCheckpoint);
    }
    if (message.btcSubmissionKey !== undefined) {
      obj.btcSubmissionKey = SubmissionKey.toJSON(message.btcSubmissionKey);
    }
    if (message.proof !== undefined) {
      obj.proof = ProofFinalizedChainInfo.toJSON(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCTimestamp>, I>>(base?: I): BTCTimestamp {
    return BTCTimestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCTimestamp>, I>>(object: I): BTCTimestamp {
    const message = createBaseBTCTimestamp();
    message.header = (object.header !== undefined && object.header !== null)
      ? IndexedHeader.fromPartial(object.header)
      : undefined;
    message.btcHeaders = (object.btcHeaders !== undefined && object.btcHeaders !== null)
      ? BTCHeaders.fromPartial(object.btcHeaders)
      : undefined;
    message.epochInfo = (object.epochInfo !== undefined && object.epochInfo !== null)
      ? Epoch.fromPartial(object.epochInfo)
      : undefined;
    message.rawCheckpoint = (object.rawCheckpoint !== undefined && object.rawCheckpoint !== null)
      ? RawCheckpoint.fromPartial(object.rawCheckpoint)
      : undefined;
    message.btcSubmissionKey = (object.btcSubmissionKey !== undefined && object.btcSubmissionKey !== null)
      ? SubmissionKey.fromPartial(object.btcSubmissionKey)
      : undefined;
    message.proof = (object.proof !== undefined && object.proof !== null)
      ? ProofFinalizedChainInfo.fromPartial(object.proof)
      : undefined;
    return message;
  },
};

function createBaseConsumerSlashingIBCPacket(): ConsumerSlashingIBCPacket {
  return { evidence: undefined };
}

export const ConsumerSlashingIBCPacket: MessageFns<ConsumerSlashingIBCPacket> = {
  encode(message: ConsumerSlashingIBCPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evidence !== undefined) {
      Evidence.encode(message.evidence, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerSlashingIBCPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerSlashingIBCPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evidence = Evidence.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerSlashingIBCPacket {
    return { evidence: isSet(object.evidence) ? Evidence.fromJSON(object.evidence) : undefined };
  },

  toJSON(message: ConsumerSlashingIBCPacket): unknown {
    const obj: any = {};
    if (message.evidence !== undefined) {
      obj.evidence = Evidence.toJSON(message.evidence);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerSlashingIBCPacket>, I>>(base?: I): ConsumerSlashingIBCPacket {
    return ConsumerSlashingIBCPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerSlashingIBCPacket>, I>>(object: I): ConsumerSlashingIBCPacket {
    const message = createBaseConsumerSlashingIBCPacket();
    message.evidence = (object.evidence !== undefined && object.evidence !== null)
      ? Evidence.fromPartial(object.evidence)
      : undefined;
    return message;
  },
};

function createBaseBSNBaseBTCHeaderIBCPacket(): BSNBaseBTCHeaderIBCPacket {
  return { baseBtcHeader: undefined };
}

export const BSNBaseBTCHeaderIBCPacket: MessageFns<BSNBaseBTCHeaderIBCPacket> = {
  encode(message: BSNBaseBTCHeaderIBCPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseBtcHeader !== undefined) {
      BTCHeaderInfo.encode(message.baseBtcHeader, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BSNBaseBTCHeaderIBCPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBSNBaseBTCHeaderIBCPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseBtcHeader = BTCHeaderInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BSNBaseBTCHeaderIBCPacket {
    return { baseBtcHeader: isSet(object.baseBtcHeader) ? BTCHeaderInfo.fromJSON(object.baseBtcHeader) : undefined };
  },

  toJSON(message: BSNBaseBTCHeaderIBCPacket): unknown {
    const obj: any = {};
    if (message.baseBtcHeader !== undefined) {
      obj.baseBtcHeader = BTCHeaderInfo.toJSON(message.baseBtcHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BSNBaseBTCHeaderIBCPacket>, I>>(base?: I): BSNBaseBTCHeaderIBCPacket {
    return BSNBaseBTCHeaderIBCPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BSNBaseBTCHeaderIBCPacket>, I>>(object: I): BSNBaseBTCHeaderIBCPacket {
    const message = createBaseBSNBaseBTCHeaderIBCPacket();
    message.baseBtcHeader = (object.baseBtcHeader !== undefined && object.baseBtcHeader !== null)
      ? BTCHeaderInfo.fromPartial(object.baseBtcHeader)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
