// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: babylon/zoneconcierge/v1/zoneconcierge.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { ProofOps } from "../../../tendermint/crypto/proof";
import { SubmissionKey, TransactionInfo } from "../../btccheckpoint/v1/btccheckpoint";
import { BTCHeaderInfo } from "../../btclightclient/v1/btclightclient";
import { ValidatorWithBlsKey } from "../../checkpointing/v1/bls_key";
import { RawCheckpoint } from "../../checkpointing/v1/checkpoint";
import { Epoch } from "../../epoching/v1/epoching";

export const protobufPackage = "babylon.zoneconcierge.v1";

/** IndexedHeader is the metadata of a Consumer header */
export interface IndexedHeader {
  /** consumer_id is the unique ID of the consumer */
  consumerId: string;
  /** hash is the hash of this header */
  hash: Uint8Array;
  /**
   * height is the height of this header on the Consumer's ledger.
   * (hash, height) jointly provide the position of the header on the Consumer ledger
   */
  height: number;
  /**
   * time is the timestamp of this header on the Consumer's ledger.
   * It is needed for a Consumer to unbond all mature validators/delegations before
   * this timestamp, when this header is BTC-finalised
   */
  time:
    | Date
    | undefined;
  /**
   * babylon_header_hash is the hash of the babylon block that includes this Consumer
   * header
   */
  babylonHeaderHash: Uint8Array;
  /**
   * babylon_header_height is the height of the babylon block that includes this
   * Consumer header
   */
  babylonHeaderHeight: number;
  /** epoch is the epoch number of this header on Babylon ledger */
  babylonEpoch: number;
  /**
   * babylon_tx_hash is the hash of the tx that includes this header
   * (babylon_block_height, babylon_tx_hash) jointly provides the position of
   * the header on Babylon ledger
   */
  babylonTxHash: Uint8Array;
}

/** ChainInfo is the information of a Consumer */
export interface ChainInfo {
  /** consumer_id is the ID of the consumer */
  consumerId: string;
  /** latest_header is the latest header in Consumer's canonical chain */
  latestHeader:
    | IndexedHeader
    | undefined;
  /**
   * timestamped_headers_count is the number of timestamped headers in the Consumer's
   * canonical chain
   */
  timestampedHeadersCount: number;
}

/**
 * ChainInfoWithProof is the chain info with a proof that the latest header in
 * the chain info is included in the epoch
 */
export interface ChainInfoWithProof {
  chainInfo:
    | ChainInfo
    | undefined;
  /**
   * proof_header_in_epoch is an inclusion proof that the latest_header in chain_info
   * is committed  to `app_hash` of the sealer header of latest_header.babylon_epoch
   * this field is optional
   */
  proofHeaderInEpoch: ProofOps | undefined;
}

/** FinalizedChainInfo is the information of a Consumer that is BTC-finalised */
export interface FinalizedChainInfo {
  /** consumer_id is the ID of the consumer */
  consumerId: string;
  /** finalized_chain_info is the info of the Consumer */
  finalizedChainInfo:
    | ChainInfo
    | undefined;
  /** epoch_info is the metadata of the last BTC-finalised epoch */
  epochInfo:
    | Epoch
    | undefined;
  /** raw_checkpoint is the raw checkpoint of this epoch */
  rawCheckpoint:
    | RawCheckpoint
    | undefined;
  /**
   * btc_submission_key is position of two BTC txs that include the raw
   * checkpoint of this epoch
   */
  btcSubmissionKey:
    | SubmissionKey
    | undefined;
  /** proof is the proof that the chain info is finalized */
  proof: ProofFinalizedChainInfo | undefined;
}

/**
 * ProofEpochSealed is the proof that an epoch is sealed by the sealer header,
 * i.e., the 2nd header of the next epoch With the access of metadata
 * - Metadata of this epoch, which includes the sealer header
 * - Raw checkpoint of this epoch
 * The verifier can perform the following verification rules:
 * - The raw checkpoint's `app_hash` is same as in the sealer header
 * - More than 2/3 (in voting power) validators in the validator set of this
 * epoch have signed `app_hash` of the sealer header
 * - The epoch metadata is committed to the `app_hash` of the sealer header
 * - The validator set is committed to the `app_hash` of the sealer header
 */
export interface ProofEpochSealed {
  /**
   * validator_set is the validator set of the sealed epoch
   * This validator set has generated a BLS multisig on `app_hash` of
   * the sealer header
   */
  validatorSet: ValidatorWithBlsKey[];
  /**
   * proof_epoch_info is the Merkle proof that the epoch's metadata is committed
   * to `app_hash` of the sealer header
   */
  proofEpochInfo:
    | ProofOps
    | undefined;
  /**
   * proof_epoch_info is the Merkle proof that the epoch's validator set is
   * committed to `app_hash` of the sealer header
   */
  proofEpochValSet: ProofOps | undefined;
}

/**
 * ProofFinalizedChainInfo is a set of proofs that attest a chain info is
 * BTC-finalised
 */
export interface ProofFinalizedChainInfo {
  /**
   * proof_consumer_header_in_epoch is the proof that the Consumer's header is timestamped
   * within a certain epoch
   */
  proofConsumerHeaderInEpoch:
    | ProofOps
    | undefined;
  /** proof_epoch_sealed is the proof that the epoch is sealed */
  proofEpochSealed:
    | ProofEpochSealed
    | undefined;
  /**
   * proof_epoch_submitted is the proof that the epoch's checkpoint is included
   * in BTC ledger It is the two TransactionInfo in the best (i.e., earliest)
   * checkpoint submission
   */
  proofEpochSubmitted: TransactionInfo[];
}

/** Btc light client chain segment grown during last finalized epoch */
export interface BTCChainSegment {
  btcHeaders: BTCHeaderInfo[];
}

/**
 * ConsumerBTCState stores per-consumer BTC synchronization state
 * This includes both the base header and the last sent segment
 */
export interface ConsumerBTCState {
  /**
   * base_header is the base BTC header for this consumer
   * This represents the starting point from which BTC headers are synchronized
   */
  baseHeader:
    | BTCHeaderInfo
    | undefined;
  /**
   * last_sent_segment is the last segment of BTC headers sent to this consumer
   * This is used to determine the next headers to send and handle reorgs
   */
  lastSentSegment: BTCChainSegment | undefined;
}

function createBaseIndexedHeader(): IndexedHeader {
  return {
    consumerId: "",
    hash: new Uint8Array(0),
    height: 0,
    time: undefined,
    babylonHeaderHash: new Uint8Array(0),
    babylonHeaderHeight: 0,
    babylonEpoch: 0,
    babylonTxHash: new Uint8Array(0),
  };
}

export const IndexedHeader: MessageFns<IndexedHeader> = {
  encode(message: IndexedHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerId !== "") {
      writer.uint32(10).string(message.consumerId);
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    if (message.height !== 0) {
      writer.uint32(24).uint64(message.height);
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(34).fork()).join();
    }
    if (message.babylonHeaderHash.length !== 0) {
      writer.uint32(42).bytes(message.babylonHeaderHash);
    }
    if (message.babylonHeaderHeight !== 0) {
      writer.uint32(48).uint64(message.babylonHeaderHeight);
    }
    if (message.babylonEpoch !== 0) {
      writer.uint32(56).uint64(message.babylonEpoch);
    }
    if (message.babylonTxHash.length !== 0) {
      writer.uint32(66).bytes(message.babylonTxHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexedHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexedHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.babylonHeaderHash = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.babylonHeaderHeight = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.babylonEpoch = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.babylonTxHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexedHeader {
    return {
      consumerId: isSet(object.consumerId) ? globalThis.String(object.consumerId) : "",
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      babylonHeaderHash: isSet(object.babylonHeaderHash)
        ? bytesFromBase64(object.babylonHeaderHash)
        : new Uint8Array(0),
      babylonHeaderHeight: isSet(object.babylonHeaderHeight) ? globalThis.Number(object.babylonHeaderHeight) : 0,
      babylonEpoch: isSet(object.babylonEpoch) ? globalThis.Number(object.babylonEpoch) : 0,
      babylonTxHash: isSet(object.babylonTxHash) ? bytesFromBase64(object.babylonTxHash) : new Uint8Array(0),
    };
  },

  toJSON(message: IndexedHeader): unknown {
    const obj: any = {};
    if (message.consumerId !== "") {
      obj.consumerId = message.consumerId;
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.babylonHeaderHash.length !== 0) {
      obj.babylonHeaderHash = base64FromBytes(message.babylonHeaderHash);
    }
    if (message.babylonHeaderHeight !== 0) {
      obj.babylonHeaderHeight = Math.round(message.babylonHeaderHeight);
    }
    if (message.babylonEpoch !== 0) {
      obj.babylonEpoch = Math.round(message.babylonEpoch);
    }
    if (message.babylonTxHash.length !== 0) {
      obj.babylonTxHash = base64FromBytes(message.babylonTxHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IndexedHeader>, I>>(base?: I): IndexedHeader {
    return IndexedHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IndexedHeader>, I>>(object: I): IndexedHeader {
    const message = createBaseIndexedHeader();
    message.consumerId = object.consumerId ?? "";
    message.hash = object.hash ?? new Uint8Array(0);
    message.height = object.height ?? 0;
    message.time = object.time ?? undefined;
    message.babylonHeaderHash = object.babylonHeaderHash ?? new Uint8Array(0);
    message.babylonHeaderHeight = object.babylonHeaderHeight ?? 0;
    message.babylonEpoch = object.babylonEpoch ?? 0;
    message.babylonTxHash = object.babylonTxHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseChainInfo(): ChainInfo {
  return { consumerId: "", latestHeader: undefined, timestampedHeadersCount: 0 };
}

export const ChainInfo: MessageFns<ChainInfo> = {
  encode(message: ChainInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerId !== "") {
      writer.uint32(10).string(message.consumerId);
    }
    if (message.latestHeader !== undefined) {
      IndexedHeader.encode(message.latestHeader, writer.uint32(18).fork()).join();
    }
    if (message.timestampedHeadersCount !== 0) {
      writer.uint32(24).uint64(message.timestampedHeadersCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.latestHeader = IndexedHeader.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestampedHeadersCount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfo {
    return {
      consumerId: isSet(object.consumerId) ? globalThis.String(object.consumerId) : "",
      latestHeader: isSet(object.latestHeader) ? IndexedHeader.fromJSON(object.latestHeader) : undefined,
      timestampedHeadersCount: isSet(object.timestampedHeadersCount)
        ? globalThis.Number(object.timestampedHeadersCount)
        : 0,
    };
  },

  toJSON(message: ChainInfo): unknown {
    const obj: any = {};
    if (message.consumerId !== "") {
      obj.consumerId = message.consumerId;
    }
    if (message.latestHeader !== undefined) {
      obj.latestHeader = IndexedHeader.toJSON(message.latestHeader);
    }
    if (message.timestampedHeadersCount !== 0) {
      obj.timestampedHeadersCount = Math.round(message.timestampedHeadersCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInfo>, I>>(base?: I): ChainInfo {
    return ChainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInfo>, I>>(object: I): ChainInfo {
    const message = createBaseChainInfo();
    message.consumerId = object.consumerId ?? "";
    message.latestHeader = (object.latestHeader !== undefined && object.latestHeader !== null)
      ? IndexedHeader.fromPartial(object.latestHeader)
      : undefined;
    message.timestampedHeadersCount = object.timestampedHeadersCount ?? 0;
    return message;
  },
};

function createBaseChainInfoWithProof(): ChainInfoWithProof {
  return { chainInfo: undefined, proofHeaderInEpoch: undefined };
}

export const ChainInfoWithProof: MessageFns<ChainInfoWithProof> = {
  encode(message: ChainInfoWithProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainInfo !== undefined) {
      ChainInfo.encode(message.chainInfo, writer.uint32(10).fork()).join();
    }
    if (message.proofHeaderInEpoch !== undefined) {
      ProofOps.encode(message.proofHeaderInEpoch, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainInfoWithProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfoWithProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainInfo = ChainInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofHeaderInEpoch = ProofOps.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfoWithProof {
    return {
      chainInfo: isSet(object.chainInfo) ? ChainInfo.fromJSON(object.chainInfo) : undefined,
      proofHeaderInEpoch: isSet(object.proofHeaderInEpoch) ? ProofOps.fromJSON(object.proofHeaderInEpoch) : undefined,
    };
  },

  toJSON(message: ChainInfoWithProof): unknown {
    const obj: any = {};
    if (message.chainInfo !== undefined) {
      obj.chainInfo = ChainInfo.toJSON(message.chainInfo);
    }
    if (message.proofHeaderInEpoch !== undefined) {
      obj.proofHeaderInEpoch = ProofOps.toJSON(message.proofHeaderInEpoch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInfoWithProof>, I>>(base?: I): ChainInfoWithProof {
    return ChainInfoWithProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInfoWithProof>, I>>(object: I): ChainInfoWithProof {
    const message = createBaseChainInfoWithProof();
    message.chainInfo = (object.chainInfo !== undefined && object.chainInfo !== null)
      ? ChainInfo.fromPartial(object.chainInfo)
      : undefined;
    message.proofHeaderInEpoch = (object.proofHeaderInEpoch !== undefined && object.proofHeaderInEpoch !== null)
      ? ProofOps.fromPartial(object.proofHeaderInEpoch)
      : undefined;
    return message;
  },
};

function createBaseFinalizedChainInfo(): FinalizedChainInfo {
  return {
    consumerId: "",
    finalizedChainInfo: undefined,
    epochInfo: undefined,
    rawCheckpoint: undefined,
    btcSubmissionKey: undefined,
    proof: undefined,
  };
}

export const FinalizedChainInfo: MessageFns<FinalizedChainInfo> = {
  encode(message: FinalizedChainInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerId !== "") {
      writer.uint32(10).string(message.consumerId);
    }
    if (message.finalizedChainInfo !== undefined) {
      ChainInfo.encode(message.finalizedChainInfo, writer.uint32(18).fork()).join();
    }
    if (message.epochInfo !== undefined) {
      Epoch.encode(message.epochInfo, writer.uint32(26).fork()).join();
    }
    if (message.rawCheckpoint !== undefined) {
      RawCheckpoint.encode(message.rawCheckpoint, writer.uint32(34).fork()).join();
    }
    if (message.btcSubmissionKey !== undefined) {
      SubmissionKey.encode(message.btcSubmissionKey, writer.uint32(42).fork()).join();
    }
    if (message.proof !== undefined) {
      ProofFinalizedChainInfo.encode(message.proof, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizedChainInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizedChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.finalizedChainInfo = ChainInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.epochInfo = Epoch.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rawCheckpoint = RawCheckpoint.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.btcSubmissionKey = SubmissionKey.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.proof = ProofFinalizedChainInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizedChainInfo {
    return {
      consumerId: isSet(object.consumerId) ? globalThis.String(object.consumerId) : "",
      finalizedChainInfo: isSet(object.finalizedChainInfo) ? ChainInfo.fromJSON(object.finalizedChainInfo) : undefined,
      epochInfo: isSet(object.epochInfo) ? Epoch.fromJSON(object.epochInfo) : undefined,
      rawCheckpoint: isSet(object.rawCheckpoint) ? RawCheckpoint.fromJSON(object.rawCheckpoint) : undefined,
      btcSubmissionKey: isSet(object.btcSubmissionKey) ? SubmissionKey.fromJSON(object.btcSubmissionKey) : undefined,
      proof: isSet(object.proof) ? ProofFinalizedChainInfo.fromJSON(object.proof) : undefined,
    };
  },

  toJSON(message: FinalizedChainInfo): unknown {
    const obj: any = {};
    if (message.consumerId !== "") {
      obj.consumerId = message.consumerId;
    }
    if (message.finalizedChainInfo !== undefined) {
      obj.finalizedChainInfo = ChainInfo.toJSON(message.finalizedChainInfo);
    }
    if (message.epochInfo !== undefined) {
      obj.epochInfo = Epoch.toJSON(message.epochInfo);
    }
    if (message.rawCheckpoint !== undefined) {
      obj.rawCheckpoint = RawCheckpoint.toJSON(message.rawCheckpoint);
    }
    if (message.btcSubmissionKey !== undefined) {
      obj.btcSubmissionKey = SubmissionKey.toJSON(message.btcSubmissionKey);
    }
    if (message.proof !== undefined) {
      obj.proof = ProofFinalizedChainInfo.toJSON(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalizedChainInfo>, I>>(base?: I): FinalizedChainInfo {
    return FinalizedChainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalizedChainInfo>, I>>(object: I): FinalizedChainInfo {
    const message = createBaseFinalizedChainInfo();
    message.consumerId = object.consumerId ?? "";
    message.finalizedChainInfo = (object.finalizedChainInfo !== undefined && object.finalizedChainInfo !== null)
      ? ChainInfo.fromPartial(object.finalizedChainInfo)
      : undefined;
    message.epochInfo = (object.epochInfo !== undefined && object.epochInfo !== null)
      ? Epoch.fromPartial(object.epochInfo)
      : undefined;
    message.rawCheckpoint = (object.rawCheckpoint !== undefined && object.rawCheckpoint !== null)
      ? RawCheckpoint.fromPartial(object.rawCheckpoint)
      : undefined;
    message.btcSubmissionKey = (object.btcSubmissionKey !== undefined && object.btcSubmissionKey !== null)
      ? SubmissionKey.fromPartial(object.btcSubmissionKey)
      : undefined;
    message.proof = (object.proof !== undefined && object.proof !== null)
      ? ProofFinalizedChainInfo.fromPartial(object.proof)
      : undefined;
    return message;
  },
};

function createBaseProofEpochSealed(): ProofEpochSealed {
  return { validatorSet: [], proofEpochInfo: undefined, proofEpochValSet: undefined };
}

export const ProofEpochSealed: MessageFns<ProofEpochSealed> = {
  encode(message: ProofEpochSealed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.validatorSet) {
      ValidatorWithBlsKey.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.proofEpochInfo !== undefined) {
      ProofOps.encode(message.proofEpochInfo, writer.uint32(18).fork()).join();
    }
    if (message.proofEpochValSet !== undefined) {
      ProofOps.encode(message.proofEpochValSet, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProofEpochSealed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofEpochSealed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorSet.push(ValidatorWithBlsKey.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofEpochInfo = ProofOps.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proofEpochValSet = ProofOps.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofEpochSealed {
    return {
      validatorSet: globalThis.Array.isArray(object?.validatorSet)
        ? object.validatorSet.map((e: any) => ValidatorWithBlsKey.fromJSON(e))
        : [],
      proofEpochInfo: isSet(object.proofEpochInfo) ? ProofOps.fromJSON(object.proofEpochInfo) : undefined,
      proofEpochValSet: isSet(object.proofEpochValSet) ? ProofOps.fromJSON(object.proofEpochValSet) : undefined,
    };
  },

  toJSON(message: ProofEpochSealed): unknown {
    const obj: any = {};
    if (message.validatorSet?.length) {
      obj.validatorSet = message.validatorSet.map((e) => ValidatorWithBlsKey.toJSON(e));
    }
    if (message.proofEpochInfo !== undefined) {
      obj.proofEpochInfo = ProofOps.toJSON(message.proofEpochInfo);
    }
    if (message.proofEpochValSet !== undefined) {
      obj.proofEpochValSet = ProofOps.toJSON(message.proofEpochValSet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProofEpochSealed>, I>>(base?: I): ProofEpochSealed {
    return ProofEpochSealed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProofEpochSealed>, I>>(object: I): ProofEpochSealed {
    const message = createBaseProofEpochSealed();
    message.validatorSet = object.validatorSet?.map((e) => ValidatorWithBlsKey.fromPartial(e)) || [];
    message.proofEpochInfo = (object.proofEpochInfo !== undefined && object.proofEpochInfo !== null)
      ? ProofOps.fromPartial(object.proofEpochInfo)
      : undefined;
    message.proofEpochValSet = (object.proofEpochValSet !== undefined && object.proofEpochValSet !== null)
      ? ProofOps.fromPartial(object.proofEpochValSet)
      : undefined;
    return message;
  },
};

function createBaseProofFinalizedChainInfo(): ProofFinalizedChainInfo {
  return { proofConsumerHeaderInEpoch: undefined, proofEpochSealed: undefined, proofEpochSubmitted: [] };
}

export const ProofFinalizedChainInfo: MessageFns<ProofFinalizedChainInfo> = {
  encode(message: ProofFinalizedChainInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proofConsumerHeaderInEpoch !== undefined) {
      ProofOps.encode(message.proofConsumerHeaderInEpoch, writer.uint32(10).fork()).join();
    }
    if (message.proofEpochSealed !== undefined) {
      ProofEpochSealed.encode(message.proofEpochSealed, writer.uint32(18).fork()).join();
    }
    for (const v of message.proofEpochSubmitted) {
      TransactionInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProofFinalizedChainInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofFinalizedChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofConsumerHeaderInEpoch = ProofOps.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofEpochSealed = ProofEpochSealed.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proofEpochSubmitted.push(TransactionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofFinalizedChainInfo {
    return {
      proofConsumerHeaderInEpoch: isSet(object.proofConsumerHeaderInEpoch)
        ? ProofOps.fromJSON(object.proofConsumerHeaderInEpoch)
        : undefined,
      proofEpochSealed: isSet(object.proofEpochSealed) ? ProofEpochSealed.fromJSON(object.proofEpochSealed) : undefined,
      proofEpochSubmitted: globalThis.Array.isArray(object?.proofEpochSubmitted)
        ? object.proofEpochSubmitted.map((e: any) => TransactionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProofFinalizedChainInfo): unknown {
    const obj: any = {};
    if (message.proofConsumerHeaderInEpoch !== undefined) {
      obj.proofConsumerHeaderInEpoch = ProofOps.toJSON(message.proofConsumerHeaderInEpoch);
    }
    if (message.proofEpochSealed !== undefined) {
      obj.proofEpochSealed = ProofEpochSealed.toJSON(message.proofEpochSealed);
    }
    if (message.proofEpochSubmitted?.length) {
      obj.proofEpochSubmitted = message.proofEpochSubmitted.map((e) => TransactionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProofFinalizedChainInfo>, I>>(base?: I): ProofFinalizedChainInfo {
    return ProofFinalizedChainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProofFinalizedChainInfo>, I>>(object: I): ProofFinalizedChainInfo {
    const message = createBaseProofFinalizedChainInfo();
    message.proofConsumerHeaderInEpoch =
      (object.proofConsumerHeaderInEpoch !== undefined && object.proofConsumerHeaderInEpoch !== null)
        ? ProofOps.fromPartial(object.proofConsumerHeaderInEpoch)
        : undefined;
    message.proofEpochSealed = (object.proofEpochSealed !== undefined && object.proofEpochSealed !== null)
      ? ProofEpochSealed.fromPartial(object.proofEpochSealed)
      : undefined;
    message.proofEpochSubmitted = object.proofEpochSubmitted?.map((e) => TransactionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBTCChainSegment(): BTCChainSegment {
  return { btcHeaders: [] };
}

export const BTCChainSegment: MessageFns<BTCChainSegment> = {
  encode(message: BTCChainSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.btcHeaders) {
      BTCHeaderInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCChainSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCChainSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.btcHeaders.push(BTCHeaderInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCChainSegment {
    return {
      btcHeaders: globalThis.Array.isArray(object?.btcHeaders)
        ? object.btcHeaders.map((e: any) => BTCHeaderInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BTCChainSegment): unknown {
    const obj: any = {};
    if (message.btcHeaders?.length) {
      obj.btcHeaders = message.btcHeaders.map((e) => BTCHeaderInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCChainSegment>, I>>(base?: I): BTCChainSegment {
    return BTCChainSegment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCChainSegment>, I>>(object: I): BTCChainSegment {
    const message = createBaseBTCChainSegment();
    message.btcHeaders = object.btcHeaders?.map((e) => BTCHeaderInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConsumerBTCState(): ConsumerBTCState {
  return { baseHeader: undefined, lastSentSegment: undefined };
}

export const ConsumerBTCState: MessageFns<ConsumerBTCState> = {
  encode(message: ConsumerBTCState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseHeader !== undefined) {
      BTCHeaderInfo.encode(message.baseHeader, writer.uint32(10).fork()).join();
    }
    if (message.lastSentSegment !== undefined) {
      BTCChainSegment.encode(message.lastSentSegment, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerBTCState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerBTCState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseHeader = BTCHeaderInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastSentSegment = BTCChainSegment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerBTCState {
    return {
      baseHeader: isSet(object.baseHeader) ? BTCHeaderInfo.fromJSON(object.baseHeader) : undefined,
      lastSentSegment: isSet(object.lastSentSegment) ? BTCChainSegment.fromJSON(object.lastSentSegment) : undefined,
    };
  },

  toJSON(message: ConsumerBTCState): unknown {
    const obj: any = {};
    if (message.baseHeader !== undefined) {
      obj.baseHeader = BTCHeaderInfo.toJSON(message.baseHeader);
    }
    if (message.lastSentSegment !== undefined) {
      obj.lastSentSegment = BTCChainSegment.toJSON(message.lastSentSegment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerBTCState>, I>>(base?: I): ConsumerBTCState {
    return ConsumerBTCState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerBTCState>, I>>(object: I): ConsumerBTCState {
    const message = createBaseConsumerBTCState();
    message.baseHeader = (object.baseHeader !== undefined && object.baseHeader !== null)
      ? BTCHeaderInfo.fromPartial(object.baseHeader)
      : undefined;
    message.lastSentSegment = (object.lastSentSegment !== undefined && object.lastSentSegment !== null)
      ? BTCChainSegment.fromPartial(object.lastSentSegment)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
