// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: babylon/btcstaking/v1/packet.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Description } from "../../../cosmos/staking/v1beta1/staking";
import { CovenantAdaptorSignatures, DelegatorUnbondingInfo, InclusionProof, SignatureInfo } from "./btcstaking";
import { ProofOfPossessionBTC } from "./pop";

export const protobufPackage = "babylon.btcstaking.v1";

/** SlashedFinalityProvider carries a slashed finality provider on a consumer */
export interface SlashedFinalityProvider {
  /**
   * btc_pk_hex is the Bitcoin secp256k1 PK of this finality provider
   * the PK follows encoding in BIP-340 spec in hex format
   */
  btcPkHex: string;
  /**
   * recovered_fp_btc_sk is the finality provider's BTC SK extracted due to slashing
   * this allows the consumer to verify the BTC delegation is indeed slashed
   */
  recoveredFpBtcSk: string;
}

/**
 * BTCStakingIBCPacket is an IBC packet sent from Babylon to a consumer
 * It carries a set of events related to BTC staking for a given consumer
 * It will be constructed and sent upon `EndBlock` of ZoneConcierge
 * (if there are any BTC staking events for a consumer)
 */
export interface BTCStakingIBCPacket {
  newFp: NewFinalityProvider[];
  activeDel: ActiveBTCDelegation[];
  slashedDel: SlashedBTCDelegation[];
  unbondedDel: UnbondedBTCDelegation[];
}

/**
 * NewFinalityProvider is an IBC packet sent from Babylon to consumer
 * upon a newly registered finality provider on this consumer
 */
export interface NewFinalityProvider {
  /** description defines the description terms for the finality provider. */
  description:
    | Description
    | undefined;
  /**
   * commission defines the commission rate of the finality provider.
   * It forms as a string converted from "cosmossdk.io/math.LegacyDec"
   */
  commission: string;
  /** addr is the bech32 address identifier of the finality provider. */
  addr: string;
  /**
   * btc_pk_hex is the Bitcoin secp256k1 PK of this finality provider
   * the PK follows encoding in BIP-340 spec in hex format
   */
  btcPkHex: string;
  /** pop is the proof of possession of babylon_pk and btc_pk */
  pop:
    | ProofOfPossessionBTC
    | undefined;
  /**
   * bsn_id is the ID of the BSN the finality provider is operating on.
   * If it's missing / empty, it's assumed the finality provider is operating in Babylon.
   */
  bsnId: string;
}

/**
 * ActiveBTCDelegation is an IBC packet sent from Babylon to consumer
 * upon a BTC delegation newly receives covenant signatures and thus becomes active
 */
export interface ActiveBTCDelegation {
  /** staker_addr is the address to receive rewards from BTC delegation. */
  stakerAddr: string;
  /**
   * btc_pk_hex is the Bitcoin secp256k1 PK of this BTC delegation
   * the PK follows encoding in BIP-340 spec in hex format
   */
  btcPkHex: string;
  /**
   * fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
   * this BTC delegation delegates to
   */
  fpBtcPkList: string[];
  /**
   * start_height is the start BTC height of the BTC delegation
   * it is the start BTC height of the timelock
   */
  startHeight: number;
  /**
   * end_height is the end height of the BTC delegation
   * it is the end BTC height of the timelock - w
   */
  endHeight: number;
  /**
   * total_sat is the total amount of BTC stakes in this delegation
   * quantified in satoshi
   */
  totalSat: number;
  /** staking_tx is the staking tx */
  stakingTx: Uint8Array;
  /** slashing_tx is the slashing tx */
  slashingTx: Uint8Array;
  /**
   * delegator_slashing_sig is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk) as string hex.
   * It will be a part of the witness for the staking tx output.
   */
  delegatorSlashingSig: Uint8Array;
  /**
   * covenant_sigs is a list of adaptor signatures on the slashing tx
   * by each covenant member
   * It will be a part of the witness for the staking tx output.
   */
  covenantSigs: CovenantAdaptorSignatures[];
  /** staking_output_idx is the index of the staking output in the staking tx */
  stakingOutputIdx: number;
  /**
   * unbonding_time used in unbonding output timelock path and in slashing transactions
   * change outputs
   */
  unbondingTime: number;
  /** undelegation_info is the undelegation info of this delegation. */
  undelegationInfo:
    | BTCUndelegationInfo
    | undefined;
  /** params version used to validate delegation */
  paramsVersion: number;
}

/** BTCUndelegationInfo provides all necessary info about the undeleagation */
export interface BTCUndelegationInfo {
  /**
   * unbonding_tx is the transaction which will transfer the funds from staking
   * output to unbonding output. Unbonding output will usually have lower timelock
   * than staking output.
   */
  unbondingTx: Uint8Array;
  /**
   * slashing_tx is the slashing tx for unbonding transactions
   * It is partially signed by SK corresponding to btc_pk, but not signed by
   * finality provider or covenant yet.
   */
  slashingTx: Uint8Array;
  /**
   * delegator_slashing_sig is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the unbonding tx output.
   */
  delegatorSlashingSig: Uint8Array;
  /**
   * covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
   * by each covenant member
   * It will be a part of the witness for the staking tx output.
   */
  covenantSlashingSigs: CovenantAdaptorSignatures[];
  /**
   * covenant_unbonding_sig_list is the list of signatures on the unbonding tx
   * by covenant members
   * It must be provided after processing undelegate message by Babylon
   */
  covenantUnbondingSigList: SignatureInfo[];
  /**
   * delegator_unbonding_info is the information about transaction which spent
   * the staking output
   */
  delegatorUnbondingInfo: DelegatorUnbondingInfo | undefined;
}

/**
 * SlashedBTCDelegation is an IBC packet sent from Babylon Genesis to consumer
 * about a slashed BTC delegation multi-staked to a finality provider
 * securing the consumer.
 */
export interface SlashedBTCDelegation {
  /** staking tx hash of the BTC delegation. It uniquely identifies a BTC delegation */
  stakingTxHash: string;
  /**
   * recovered_fp_btc_sk is the extracted BTC SK of the finality provider on
   * this consumer
   * this allows the consumer to verify the BTC delegation is indeed slashed
   */
  recoveredFpBtcSk: string;
}

/**
 * UnbondedBTCDelegation is an IBC packet sent from Babylon to consumer
 * upon an early unbonded BTC delegation
 */
export interface UnbondedBTCDelegation {
  /** staking tx hash of the BTC delegation. It uniquely identifies a BTC delegation */
  stakingTxHash: string;
  /**
   * unbonding_tx_sig is the signature on the unbonding tx signed by the BTC delegator
   * It proves that the BTC delegator wants to unbond
   */
  unbondingTxSig: Uint8Array;
  /** stake_spending_tx is the stake spending tx */
  stakeSpendingTx: Uint8Array;
  /** proof is the inclusion proof for the stake spending tx */
  proof: InclusionProof | undefined;
}

/**
 * BTCStakingConsumerEvent defines the structure for storing BTC staking events
 * which will be later sent to consumer chains as IBC packets.
 */
export interface BTCStakingConsumerEvent {
  /** NewFinalityProvider represents the event of a new finality provider being created. */
  newFp?:
    | NewFinalityProvider
    | undefined;
  /** ActiveBTCDelegation represents the event of an active BTC delegation. */
  activeDel?:
    | ActiveBTCDelegation
    | undefined;
  /** SlashedBTCDelegation represents the event of a slashed BTC delegation. */
  slashedDel?:
    | SlashedBTCDelegation
    | undefined;
  /** UnbondedBTCDelegation represents the event of an unbonded BTC delegation. */
  unbondedDel?: UnbondedBTCDelegation | undefined;
}

function createBaseSlashedFinalityProvider(): SlashedFinalityProvider {
  return { btcPkHex: "", recoveredFpBtcSk: "" };
}

export const SlashedFinalityProvider: MessageFns<SlashedFinalityProvider> = {
  encode(message: SlashedFinalityProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.btcPkHex !== "") {
      writer.uint32(10).string(message.btcPkHex);
    }
    if (message.recoveredFpBtcSk !== "") {
      writer.uint32(18).string(message.recoveredFpBtcSk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlashedFinalityProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlashedFinalityProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.btcPkHex = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recoveredFpBtcSk = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlashedFinalityProvider {
    return {
      btcPkHex: isSet(object.btcPkHex) ? globalThis.String(object.btcPkHex) : "",
      recoveredFpBtcSk: isSet(object.recoveredFpBtcSk) ? globalThis.String(object.recoveredFpBtcSk) : "",
    };
  },

  toJSON(message: SlashedFinalityProvider): unknown {
    const obj: any = {};
    if (message.btcPkHex !== "") {
      obj.btcPkHex = message.btcPkHex;
    }
    if (message.recoveredFpBtcSk !== "") {
      obj.recoveredFpBtcSk = message.recoveredFpBtcSk;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlashedFinalityProvider>, I>>(base?: I): SlashedFinalityProvider {
    return SlashedFinalityProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlashedFinalityProvider>, I>>(object: I): SlashedFinalityProvider {
    const message = createBaseSlashedFinalityProvider();
    message.btcPkHex = object.btcPkHex ?? "";
    message.recoveredFpBtcSk = object.recoveredFpBtcSk ?? "";
    return message;
  },
};

function createBaseBTCStakingIBCPacket(): BTCStakingIBCPacket {
  return { newFp: [], activeDel: [], slashedDel: [], unbondedDel: [] };
}

export const BTCStakingIBCPacket: MessageFns<BTCStakingIBCPacket> = {
  encode(message: BTCStakingIBCPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.newFp) {
      NewFinalityProvider.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.activeDel) {
      ActiveBTCDelegation.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.slashedDel) {
      SlashedBTCDelegation.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.unbondedDel) {
      UnbondedBTCDelegation.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCStakingIBCPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCStakingIBCPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newFp.push(NewFinalityProvider.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.activeDel.push(ActiveBTCDelegation.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slashedDel.push(SlashedBTCDelegation.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unbondedDel.push(UnbondedBTCDelegation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCStakingIBCPacket {
    return {
      newFp: globalThis.Array.isArray(object?.newFp)
        ? object.newFp.map((e: any) => NewFinalityProvider.fromJSON(e))
        : [],
      activeDel: globalThis.Array.isArray(object?.activeDel)
        ? object.activeDel.map((e: any) => ActiveBTCDelegation.fromJSON(e))
        : [],
      slashedDel: globalThis.Array.isArray(object?.slashedDel)
        ? object.slashedDel.map((e: any) => SlashedBTCDelegation.fromJSON(e))
        : [],
      unbondedDel: globalThis.Array.isArray(object?.unbondedDel)
        ? object.unbondedDel.map((e: any) => UnbondedBTCDelegation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BTCStakingIBCPacket): unknown {
    const obj: any = {};
    if (message.newFp?.length) {
      obj.newFp = message.newFp.map((e) => NewFinalityProvider.toJSON(e));
    }
    if (message.activeDel?.length) {
      obj.activeDel = message.activeDel.map((e) => ActiveBTCDelegation.toJSON(e));
    }
    if (message.slashedDel?.length) {
      obj.slashedDel = message.slashedDel.map((e) => SlashedBTCDelegation.toJSON(e));
    }
    if (message.unbondedDel?.length) {
      obj.unbondedDel = message.unbondedDel.map((e) => UnbondedBTCDelegation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCStakingIBCPacket>, I>>(base?: I): BTCStakingIBCPacket {
    return BTCStakingIBCPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCStakingIBCPacket>, I>>(object: I): BTCStakingIBCPacket {
    const message = createBaseBTCStakingIBCPacket();
    message.newFp = object.newFp?.map((e) => NewFinalityProvider.fromPartial(e)) || [];
    message.activeDel = object.activeDel?.map((e) => ActiveBTCDelegation.fromPartial(e)) || [];
    message.slashedDel = object.slashedDel?.map((e) => SlashedBTCDelegation.fromPartial(e)) || [];
    message.unbondedDel = object.unbondedDel?.map((e) => UnbondedBTCDelegation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNewFinalityProvider(): NewFinalityProvider {
  return { description: undefined, commission: "", addr: "", btcPkHex: "", pop: undefined, bsnId: "" };
}

export const NewFinalityProvider: MessageFns<NewFinalityProvider> = {
  encode(message: NewFinalityProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== undefined) {
      Description.encode(message.description, writer.uint32(10).fork()).join();
    }
    if (message.commission !== "") {
      writer.uint32(18).string(message.commission);
    }
    if (message.addr !== "") {
      writer.uint32(26).string(message.addr);
    }
    if (message.btcPkHex !== "") {
      writer.uint32(34).string(message.btcPkHex);
    }
    if (message.pop !== undefined) {
      ProofOfPossessionBTC.encode(message.pop, writer.uint32(42).fork()).join();
    }
    if (message.bsnId !== "") {
      writer.uint32(66).string(message.bsnId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewFinalityProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewFinalityProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = Description.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commission = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.btcPkHex = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bsnId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewFinalityProvider {
    return {
      description: isSet(object.description) ? Description.fromJSON(object.description) : undefined,
      commission: isSet(object.commission) ? globalThis.String(object.commission) : "",
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      btcPkHex: isSet(object.btcPkHex) ? globalThis.String(object.btcPkHex) : "",
      pop: isSet(object.pop) ? ProofOfPossessionBTC.fromJSON(object.pop) : undefined,
      bsnId: isSet(object.bsnId) ? globalThis.String(object.bsnId) : "",
    };
  },

  toJSON(message: NewFinalityProvider): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = Description.toJSON(message.description);
    }
    if (message.commission !== "") {
      obj.commission = message.commission;
    }
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.btcPkHex !== "") {
      obj.btcPkHex = message.btcPkHex;
    }
    if (message.pop !== undefined) {
      obj.pop = ProofOfPossessionBTC.toJSON(message.pop);
    }
    if (message.bsnId !== "") {
      obj.bsnId = message.bsnId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewFinalityProvider>, I>>(base?: I): NewFinalityProvider {
    return NewFinalityProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewFinalityProvider>, I>>(object: I): NewFinalityProvider {
    const message = createBaseNewFinalityProvider();
    message.description = (object.description !== undefined && object.description !== null)
      ? Description.fromPartial(object.description)
      : undefined;
    message.commission = object.commission ?? "";
    message.addr = object.addr ?? "";
    message.btcPkHex = object.btcPkHex ?? "";
    message.pop = (object.pop !== undefined && object.pop !== null)
      ? ProofOfPossessionBTC.fromPartial(object.pop)
      : undefined;
    message.bsnId = object.bsnId ?? "";
    return message;
  },
};

function createBaseActiveBTCDelegation(): ActiveBTCDelegation {
  return {
    stakerAddr: "",
    btcPkHex: "",
    fpBtcPkList: [],
    startHeight: 0,
    endHeight: 0,
    totalSat: 0,
    stakingTx: new Uint8Array(0),
    slashingTx: new Uint8Array(0),
    delegatorSlashingSig: new Uint8Array(0),
    covenantSigs: [],
    stakingOutputIdx: 0,
    unbondingTime: 0,
    undelegationInfo: undefined,
    paramsVersion: 0,
  };
}

export const ActiveBTCDelegation: MessageFns<ActiveBTCDelegation> = {
  encode(message: ActiveBTCDelegation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stakerAddr !== "") {
      writer.uint32(10).string(message.stakerAddr);
    }
    if (message.btcPkHex !== "") {
      writer.uint32(18).string(message.btcPkHex);
    }
    for (const v of message.fpBtcPkList) {
      writer.uint32(26).string(v!);
    }
    if (message.startHeight !== 0) {
      writer.uint32(32).uint32(message.startHeight);
    }
    if (message.endHeight !== 0) {
      writer.uint32(40).uint32(message.endHeight);
    }
    if (message.totalSat !== 0) {
      writer.uint32(48).uint64(message.totalSat);
    }
    if (message.stakingTx.length !== 0) {
      writer.uint32(58).bytes(message.stakingTx);
    }
    if (message.slashingTx.length !== 0) {
      writer.uint32(66).bytes(message.slashingTx);
    }
    if (message.delegatorSlashingSig.length !== 0) {
      writer.uint32(74).bytes(message.delegatorSlashingSig);
    }
    for (const v of message.covenantSigs) {
      CovenantAdaptorSignatures.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.stakingOutputIdx !== 0) {
      writer.uint32(88).uint32(message.stakingOutputIdx);
    }
    if (message.unbondingTime !== 0) {
      writer.uint32(96).uint32(message.unbondingTime);
    }
    if (message.undelegationInfo !== undefined) {
      BTCUndelegationInfo.encode(message.undelegationInfo, writer.uint32(106).fork()).join();
    }
    if (message.paramsVersion !== 0) {
      writer.uint32(112).uint32(message.paramsVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActiveBTCDelegation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveBTCDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stakerAddr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.btcPkHex = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fpBtcPkList.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startHeight = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.endHeight = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalSat = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stakingTx = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.slashingTx = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.delegatorSlashingSig = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.covenantSigs.push(CovenantAdaptorSignatures.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.stakingOutputIdx = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.unbondingTime = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.undelegationInfo = BTCUndelegationInfo.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.paramsVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveBTCDelegation {
    return {
      stakerAddr: isSet(object.stakerAddr) ? globalThis.String(object.stakerAddr) : "",
      btcPkHex: isSet(object.btcPkHex) ? globalThis.String(object.btcPkHex) : "",
      fpBtcPkList: globalThis.Array.isArray(object?.fpBtcPkList)
        ? object.fpBtcPkList.map((e: any) => globalThis.String(e))
        : [],
      startHeight: isSet(object.startHeight) ? globalThis.Number(object.startHeight) : 0,
      endHeight: isSet(object.endHeight) ? globalThis.Number(object.endHeight) : 0,
      totalSat: isSet(object.totalSat) ? globalThis.Number(object.totalSat) : 0,
      stakingTx: isSet(object.stakingTx) ? bytesFromBase64(object.stakingTx) : new Uint8Array(0),
      slashingTx: isSet(object.slashingTx) ? bytesFromBase64(object.slashingTx) : new Uint8Array(0),
      delegatorSlashingSig: isSet(object.delegatorSlashingSig)
        ? bytesFromBase64(object.delegatorSlashingSig)
        : new Uint8Array(0),
      covenantSigs: globalThis.Array.isArray(object?.covenantSigs)
        ? object.covenantSigs.map((e: any) => CovenantAdaptorSignatures.fromJSON(e))
        : [],
      stakingOutputIdx: isSet(object.stakingOutputIdx) ? globalThis.Number(object.stakingOutputIdx) : 0,
      unbondingTime: isSet(object.unbondingTime) ? globalThis.Number(object.unbondingTime) : 0,
      undelegationInfo: isSet(object.undelegationInfo)
        ? BTCUndelegationInfo.fromJSON(object.undelegationInfo)
        : undefined,
      paramsVersion: isSet(object.paramsVersion) ? globalThis.Number(object.paramsVersion) : 0,
    };
  },

  toJSON(message: ActiveBTCDelegation): unknown {
    const obj: any = {};
    if (message.stakerAddr !== "") {
      obj.stakerAddr = message.stakerAddr;
    }
    if (message.btcPkHex !== "") {
      obj.btcPkHex = message.btcPkHex;
    }
    if (message.fpBtcPkList?.length) {
      obj.fpBtcPkList = message.fpBtcPkList;
    }
    if (message.startHeight !== 0) {
      obj.startHeight = Math.round(message.startHeight);
    }
    if (message.endHeight !== 0) {
      obj.endHeight = Math.round(message.endHeight);
    }
    if (message.totalSat !== 0) {
      obj.totalSat = Math.round(message.totalSat);
    }
    if (message.stakingTx.length !== 0) {
      obj.stakingTx = base64FromBytes(message.stakingTx);
    }
    if (message.slashingTx.length !== 0) {
      obj.slashingTx = base64FromBytes(message.slashingTx);
    }
    if (message.delegatorSlashingSig.length !== 0) {
      obj.delegatorSlashingSig = base64FromBytes(message.delegatorSlashingSig);
    }
    if (message.covenantSigs?.length) {
      obj.covenantSigs = message.covenantSigs.map((e) => CovenantAdaptorSignatures.toJSON(e));
    }
    if (message.stakingOutputIdx !== 0) {
      obj.stakingOutputIdx = Math.round(message.stakingOutputIdx);
    }
    if (message.unbondingTime !== 0) {
      obj.unbondingTime = Math.round(message.unbondingTime);
    }
    if (message.undelegationInfo !== undefined) {
      obj.undelegationInfo = BTCUndelegationInfo.toJSON(message.undelegationInfo);
    }
    if (message.paramsVersion !== 0) {
      obj.paramsVersion = Math.round(message.paramsVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActiveBTCDelegation>, I>>(base?: I): ActiveBTCDelegation {
    return ActiveBTCDelegation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActiveBTCDelegation>, I>>(object: I): ActiveBTCDelegation {
    const message = createBaseActiveBTCDelegation();
    message.stakerAddr = object.stakerAddr ?? "";
    message.btcPkHex = object.btcPkHex ?? "";
    message.fpBtcPkList = object.fpBtcPkList?.map((e) => e) || [];
    message.startHeight = object.startHeight ?? 0;
    message.endHeight = object.endHeight ?? 0;
    message.totalSat = object.totalSat ?? 0;
    message.stakingTx = object.stakingTx ?? new Uint8Array(0);
    message.slashingTx = object.slashingTx ?? new Uint8Array(0);
    message.delegatorSlashingSig = object.delegatorSlashingSig ?? new Uint8Array(0);
    message.covenantSigs = object.covenantSigs?.map((e) => CovenantAdaptorSignatures.fromPartial(e)) || [];
    message.stakingOutputIdx = object.stakingOutputIdx ?? 0;
    message.unbondingTime = object.unbondingTime ?? 0;
    message.undelegationInfo = (object.undelegationInfo !== undefined && object.undelegationInfo !== null)
      ? BTCUndelegationInfo.fromPartial(object.undelegationInfo)
      : undefined;
    message.paramsVersion = object.paramsVersion ?? 0;
    return message;
  },
};

function createBaseBTCUndelegationInfo(): BTCUndelegationInfo {
  return {
    unbondingTx: new Uint8Array(0),
    slashingTx: new Uint8Array(0),
    delegatorSlashingSig: new Uint8Array(0),
    covenantSlashingSigs: [],
    covenantUnbondingSigList: [],
    delegatorUnbondingInfo: undefined,
  };
}

export const BTCUndelegationInfo: MessageFns<BTCUndelegationInfo> = {
  encode(message: BTCUndelegationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unbondingTx.length !== 0) {
      writer.uint32(10).bytes(message.unbondingTx);
    }
    if (message.slashingTx.length !== 0) {
      writer.uint32(18).bytes(message.slashingTx);
    }
    if (message.delegatorSlashingSig.length !== 0) {
      writer.uint32(26).bytes(message.delegatorSlashingSig);
    }
    for (const v of message.covenantSlashingSigs) {
      CovenantAdaptorSignatures.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.covenantUnbondingSigList) {
      SignatureInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.delegatorUnbondingInfo !== undefined) {
      DelegatorUnbondingInfo.encode(message.delegatorUnbondingInfo, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCUndelegationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCUndelegationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unbondingTx = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.slashingTx = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.delegatorSlashingSig = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.covenantSlashingSigs.push(CovenantAdaptorSignatures.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.covenantUnbondingSigList.push(SignatureInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.delegatorUnbondingInfo = DelegatorUnbondingInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCUndelegationInfo {
    return {
      unbondingTx: isSet(object.unbondingTx) ? bytesFromBase64(object.unbondingTx) : new Uint8Array(0),
      slashingTx: isSet(object.slashingTx) ? bytesFromBase64(object.slashingTx) : new Uint8Array(0),
      delegatorSlashingSig: isSet(object.delegatorSlashingSig)
        ? bytesFromBase64(object.delegatorSlashingSig)
        : new Uint8Array(0),
      covenantSlashingSigs: globalThis.Array.isArray(object?.covenantSlashingSigs)
        ? object.covenantSlashingSigs.map((e: any) => CovenantAdaptorSignatures.fromJSON(e))
        : [],
      covenantUnbondingSigList: globalThis.Array.isArray(object?.covenantUnbondingSigList)
        ? object.covenantUnbondingSigList.map((e: any) => SignatureInfo.fromJSON(e))
        : [],
      delegatorUnbondingInfo: isSet(object.delegatorUnbondingInfo)
        ? DelegatorUnbondingInfo.fromJSON(object.delegatorUnbondingInfo)
        : undefined,
    };
  },

  toJSON(message: BTCUndelegationInfo): unknown {
    const obj: any = {};
    if (message.unbondingTx.length !== 0) {
      obj.unbondingTx = base64FromBytes(message.unbondingTx);
    }
    if (message.slashingTx.length !== 0) {
      obj.slashingTx = base64FromBytes(message.slashingTx);
    }
    if (message.delegatorSlashingSig.length !== 0) {
      obj.delegatorSlashingSig = base64FromBytes(message.delegatorSlashingSig);
    }
    if (message.covenantSlashingSigs?.length) {
      obj.covenantSlashingSigs = message.covenantSlashingSigs.map((e) => CovenantAdaptorSignatures.toJSON(e));
    }
    if (message.covenantUnbondingSigList?.length) {
      obj.covenantUnbondingSigList = message.covenantUnbondingSigList.map((e) => SignatureInfo.toJSON(e));
    }
    if (message.delegatorUnbondingInfo !== undefined) {
      obj.delegatorUnbondingInfo = DelegatorUnbondingInfo.toJSON(message.delegatorUnbondingInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCUndelegationInfo>, I>>(base?: I): BTCUndelegationInfo {
    return BTCUndelegationInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCUndelegationInfo>, I>>(object: I): BTCUndelegationInfo {
    const message = createBaseBTCUndelegationInfo();
    message.unbondingTx = object.unbondingTx ?? new Uint8Array(0);
    message.slashingTx = object.slashingTx ?? new Uint8Array(0);
    message.delegatorSlashingSig = object.delegatorSlashingSig ?? new Uint8Array(0);
    message.covenantSlashingSigs = object.covenantSlashingSigs?.map((e) => CovenantAdaptorSignatures.fromPartial(e)) ||
      [];
    message.covenantUnbondingSigList = object.covenantUnbondingSigList?.map((e) => SignatureInfo.fromPartial(e)) || [];
    message.delegatorUnbondingInfo =
      (object.delegatorUnbondingInfo !== undefined && object.delegatorUnbondingInfo !== null)
        ? DelegatorUnbondingInfo.fromPartial(object.delegatorUnbondingInfo)
        : undefined;
    return message;
  },
};

function createBaseSlashedBTCDelegation(): SlashedBTCDelegation {
  return { stakingTxHash: "", recoveredFpBtcSk: "" };
}

export const SlashedBTCDelegation: MessageFns<SlashedBTCDelegation> = {
  encode(message: SlashedBTCDelegation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stakingTxHash !== "") {
      writer.uint32(10).string(message.stakingTxHash);
    }
    if (message.recoveredFpBtcSk !== "") {
      writer.uint32(18).string(message.recoveredFpBtcSk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlashedBTCDelegation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlashedBTCDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stakingTxHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recoveredFpBtcSk = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlashedBTCDelegation {
    return {
      stakingTxHash: isSet(object.stakingTxHash) ? globalThis.String(object.stakingTxHash) : "",
      recoveredFpBtcSk: isSet(object.recoveredFpBtcSk) ? globalThis.String(object.recoveredFpBtcSk) : "",
    };
  },

  toJSON(message: SlashedBTCDelegation): unknown {
    const obj: any = {};
    if (message.stakingTxHash !== "") {
      obj.stakingTxHash = message.stakingTxHash;
    }
    if (message.recoveredFpBtcSk !== "") {
      obj.recoveredFpBtcSk = message.recoveredFpBtcSk;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlashedBTCDelegation>, I>>(base?: I): SlashedBTCDelegation {
    return SlashedBTCDelegation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlashedBTCDelegation>, I>>(object: I): SlashedBTCDelegation {
    const message = createBaseSlashedBTCDelegation();
    message.stakingTxHash = object.stakingTxHash ?? "";
    message.recoveredFpBtcSk = object.recoveredFpBtcSk ?? "";
    return message;
  },
};

function createBaseUnbondedBTCDelegation(): UnbondedBTCDelegation {
  return { stakingTxHash: "", unbondingTxSig: new Uint8Array(0), stakeSpendingTx: new Uint8Array(0), proof: undefined };
}

export const UnbondedBTCDelegation: MessageFns<UnbondedBTCDelegation> = {
  encode(message: UnbondedBTCDelegation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stakingTxHash !== "") {
      writer.uint32(10).string(message.stakingTxHash);
    }
    if (message.unbondingTxSig.length !== 0) {
      writer.uint32(18).bytes(message.unbondingTxSig);
    }
    if (message.stakeSpendingTx.length !== 0) {
      writer.uint32(26).bytes(message.stakeSpendingTx);
    }
    if (message.proof !== undefined) {
      InclusionProof.encode(message.proof, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnbondedBTCDelegation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnbondedBTCDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stakingTxHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unbondingTxSig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stakeSpendingTx = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.proof = InclusionProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnbondedBTCDelegation {
    return {
      stakingTxHash: isSet(object.stakingTxHash) ? globalThis.String(object.stakingTxHash) : "",
      unbondingTxSig: isSet(object.unbondingTxSig) ? bytesFromBase64(object.unbondingTxSig) : new Uint8Array(0),
      stakeSpendingTx: isSet(object.stakeSpendingTx) ? bytesFromBase64(object.stakeSpendingTx) : new Uint8Array(0),
      proof: isSet(object.proof) ? InclusionProof.fromJSON(object.proof) : undefined,
    };
  },

  toJSON(message: UnbondedBTCDelegation): unknown {
    const obj: any = {};
    if (message.stakingTxHash !== "") {
      obj.stakingTxHash = message.stakingTxHash;
    }
    if (message.unbondingTxSig.length !== 0) {
      obj.unbondingTxSig = base64FromBytes(message.unbondingTxSig);
    }
    if (message.stakeSpendingTx.length !== 0) {
      obj.stakeSpendingTx = base64FromBytes(message.stakeSpendingTx);
    }
    if (message.proof !== undefined) {
      obj.proof = InclusionProof.toJSON(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnbondedBTCDelegation>, I>>(base?: I): UnbondedBTCDelegation {
    return UnbondedBTCDelegation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnbondedBTCDelegation>, I>>(object: I): UnbondedBTCDelegation {
    const message = createBaseUnbondedBTCDelegation();
    message.stakingTxHash = object.stakingTxHash ?? "";
    message.unbondingTxSig = object.unbondingTxSig ?? new Uint8Array(0);
    message.stakeSpendingTx = object.stakeSpendingTx ?? new Uint8Array(0);
    message.proof = (object.proof !== undefined && object.proof !== null)
      ? InclusionProof.fromPartial(object.proof)
      : undefined;
    return message;
  },
};

function createBaseBTCStakingConsumerEvent(): BTCStakingConsumerEvent {
  return { newFp: undefined, activeDel: undefined, slashedDel: undefined, unbondedDel: undefined };
}

export const BTCStakingConsumerEvent: MessageFns<BTCStakingConsumerEvent> = {
  encode(message: BTCStakingConsumerEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newFp !== undefined) {
      NewFinalityProvider.encode(message.newFp, writer.uint32(10).fork()).join();
    }
    if (message.activeDel !== undefined) {
      ActiveBTCDelegation.encode(message.activeDel, writer.uint32(18).fork()).join();
    }
    if (message.slashedDel !== undefined) {
      SlashedBTCDelegation.encode(message.slashedDel, writer.uint32(26).fork()).join();
    }
    if (message.unbondedDel !== undefined) {
      UnbondedBTCDelegation.encode(message.unbondedDel, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCStakingConsumerEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCStakingConsumerEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newFp = NewFinalityProvider.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.activeDel = ActiveBTCDelegation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slashedDel = SlashedBTCDelegation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unbondedDel = UnbondedBTCDelegation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCStakingConsumerEvent {
    return {
      newFp: isSet(object.newFp) ? NewFinalityProvider.fromJSON(object.newFp) : undefined,
      activeDel: isSet(object.activeDel) ? ActiveBTCDelegation.fromJSON(object.activeDel) : undefined,
      slashedDel: isSet(object.slashedDel) ? SlashedBTCDelegation.fromJSON(object.slashedDel) : undefined,
      unbondedDel: isSet(object.unbondedDel) ? UnbondedBTCDelegation.fromJSON(object.unbondedDel) : undefined,
    };
  },

  toJSON(message: BTCStakingConsumerEvent): unknown {
    const obj: any = {};
    if (message.newFp !== undefined) {
      obj.newFp = NewFinalityProvider.toJSON(message.newFp);
    }
    if (message.activeDel !== undefined) {
      obj.activeDel = ActiveBTCDelegation.toJSON(message.activeDel);
    }
    if (message.slashedDel !== undefined) {
      obj.slashedDel = SlashedBTCDelegation.toJSON(message.slashedDel);
    }
    if (message.unbondedDel !== undefined) {
      obj.unbondedDel = UnbondedBTCDelegation.toJSON(message.unbondedDel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCStakingConsumerEvent>, I>>(base?: I): BTCStakingConsumerEvent {
    return BTCStakingConsumerEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCStakingConsumerEvent>, I>>(object: I): BTCStakingConsumerEvent {
    const message = createBaseBTCStakingConsumerEvent();
    message.newFp = (object.newFp !== undefined && object.newFp !== null)
      ? NewFinalityProvider.fromPartial(object.newFp)
      : undefined;
    message.activeDel = (object.activeDel !== undefined && object.activeDel !== null)
      ? ActiveBTCDelegation.fromPartial(object.activeDel)
      : undefined;
    message.slashedDel = (object.slashedDel !== undefined && object.slashedDel !== null)
      ? SlashedBTCDelegation.fromPartial(object.slashedDel)
      : undefined;
    message.unbondedDel = (object.unbondedDel !== undefined && object.unbondedDel !== null)
      ? UnbondedBTCDelegation.fromPartial(object.unbondedDel)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
